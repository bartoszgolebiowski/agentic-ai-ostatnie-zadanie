# -*- coding: utf-8 -*-
"""
Leaderboard Card Parser - extracts evaluation criteria from markdown.

Based on lesson 5.3 methodology.
"""

from pydantic import BaseModel, Field
from typing import List
import re


class CheckDefinition(BaseModel):
    """
    Definition of a single evaluation criterion.

    Extracted from leaderboard markdown file.
    """
    id: str = Field(..., description="Unique ID (LC-001, LC-002, etc.)")
    title: str = Field(..., description="Short title of criterion")
    description: str = Field(..., description="Full criterion text")
    priority: str = Field(..., description="MUST-HAVE or SHOULD-HAVE")
    examples_positive: List[str] = Field(default_factory=list)
    examples_negative: List[str] = Field(default_factory=list)

    def to_prompt_fragment(self) -> str:
        """Format check as prompt fragment for LLM."""
        return (
            f"**{self.id} - {self.title}** ({self.priority})\n"
            f"Kryterium: {self.description}\n"
        )


def parse_leaderboard_card(filepath: str) -> List[CheckDefinition]:
    """
    Parse leaderboard markdown file to extract criteria.

    Format expected:
    #### LC-001 ðŸ”´ MUST-HAVE | Title
    - **Kryterium**: Description
    - **PrzykÅ‚ady pozytywne**: ...
    - **PrzykÅ‚ady negatywne**: ...

    Args:
        filepath: Path to leaderboard_card_coach.md

    Returns:
        List of CheckDefinition objects
    """
    with open(filepath, 'r', encoding='utf-8') as f:
        content = f.read()

    checks = []

    # Split by #### headers (each criterion section)
    sections = re.split(r'\n#### ', content)

    for section in sections[1:]:  # Skip preamble
        if not section.strip():
            continue

        lines = section.split('\n')
        header = lines[0]

        # Extract ID (LC-001, LC-002, etc.)
        id_match = re.search(r'(LC-\d{3})', header)
        if not id_match:
            continue
        check_id = id_match.group(1)

        # Extract priority
        if 'ðŸ”´ MUST-HAVE' in header or 'MUST-HAVE' in header:
            priority = "MUST-HAVE"
        elif 'ðŸŸ¡ SHOULD-HAVE' in header or 'SHOULD-HAVE' in header:
            priority = "SHOULD-HAVE"
        else:
            continue

        # Extract title (after | symbol)
        title_match = re.search(r'\|\s*(.+)$', header)
        title = title_match.group(1).strip() if title_match else ""

        # Extract description (after "- **Kryterium**:")
        description = ""
        for line in lines:
            if '**Kryterium**:' in line or '**Kryterium:**' in line:
                description = line.split('**Kryterium**')[-1].strip().lstrip(':').strip()
                break

        # Extract examples (simplified - can be enhanced)
        examples_positive = []
        examples_negative = []

        in_positive = False
        in_negative = False

        for line in lines:
            if '**PrzykÅ‚ady pozytywne**' in line or '**PrzykÅ‚ady pozytywne**:' in line:
                in_positive = True
                in_negative = False
            elif '**PrzykÅ‚ady negatywne**' in line or '**PrzykÅ‚ady negatywne**:' in line:
                in_positive = False
                in_negative = True
            elif line.strip().startswith('1.') or line.strip().startswith('2.'):
                example = line.strip()[2:].strip().strip('"')
                if in_positive:
                    examples_positive.append(example)
                elif in_negative:
                    examples_negative.append(example)

        checks.append(CheckDefinition(
            id=check_id,
            title=title,
            description=description,
            priority=priority,
            examples_positive=examples_positive,
            examples_negative=examples_negative
        ))

    return checks


def filter_checks_by_priority(checks: List[CheckDefinition], priority: str) -> List[CheckDefinition]:
    """
    Filter checks by priority.

    Args:
        checks: All parsed checks
        priority: "MUST-HAVE", "SHOULD-HAVE", or "ALL"

    Returns:
        Filtered list of checks
    """
    if priority == "ALL":
        return checks

    return [c for c in checks if c.priority == priority]
